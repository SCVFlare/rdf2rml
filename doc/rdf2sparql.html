<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>rdf2sparql - Convert RDF examples to SPARQL queries (OntoRefine or TARQL)</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Options">Options</a></li>
      <li><a href="#Prerequisites">Prerequisites</a></li>
      <li><a href="#Process">Process</a></li>
      <li><a href="#RDF-Model-Examples">RDF Model Examples</a>
        <ul>
          <li><a href="#RDF-Model:-CrunchBase-Organizations">RDF Model: CrunchBase Organizations</a></li>
          <li><a href="#RDF-Model:-Customers">RDF Model: Customers</a></li>
          <li><a href="#RDF-Model:-Annual-Revenue-by-Permalink">RDF Model: Annual Revenue by Permalink</a></li>
          <li><a href="#RDF-Model:-Grant-Spending-Categories">RDF Model: Grant Spending Categories</a></li>
          <li><a href="#RDF-Model-Concatenation">RDF Model Concatenation</a></li>
        </ul>
      </li>
      <li><a href="#Preprocessor-Macros">Preprocessor Macros</a>
        <ul>
          <li><a href="#Macro-Best-Practices">Macro Best Practices</a></li>
        </ul>
      </li>
      <li><a href="#Generated-SPARQL">Generated SPARQL</a>
        <ul>
          <li><a href="#Insert-Patterns:-Crunchbase-Organizations">Insert Patterns: Crunchbase Organizations</a></li>
          <li><a href="#Generated-Pre-Binds">Generated Pre-Binds</a></li>
          <li><a href="#Generated-Binds:-CrunchBase-Organizations">Generated Binds: CrunchBase Organizations</a></li>
          <li><a href="#Generated-Binds:-Customers">Generated Binds: Customers</a></li>
          <li><a href="#Generated-Update:-Annual-Revenue-by-Permalink">Generated Update: Annual Revenue by Permalink</a></li>
          <li><a href="#Generated-Binds:-Spending-Categories">Generated Binds: Spending Categories</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>rdf2sparql - Convert RDF examples to SPARQL queries (OntoRefine or TARQL)</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>  perl rdf2sparql.pl             model.ttl | cat common.h prefixes.rq - | cpp -P -C -nostdinc - &gt; model-ontorefine.ru
  perl rdf2sparql.pl --construct model.ttl | cat common.h prefixes.rq - | cpp -P -C -nostdinc - &gt; model-ontorefine.rq
  perl rdf2sparql.pl --tarql     model.ttl | cat common.h prefixes.rq - | cpp -P -C -nostdinc - &gt; model.tarql

  Options:
    --construct: generate CONSTRUCT query (default is UPDATE; applies only for OntoRefine)
    --tarql: generate for TARQL (default is OntoRefine)</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p><b>rdf2sparql</b> converts an RDF example with embedded CSV/TSV column names into a SPARQL query for:</p>

<ul>

<li><p><a href="https://tarql.github.io/">TARQL</a>, which is a is a high-speed streaming convertor. It&#39;s a SPARQL processor for tabular data, where each column <b>col</b> of each row is exposed as a variable binding <b>?col</b> (punctuation is replaced with underscores). See <a href="https://github.com/tarql/tarql/releases">releases</a>, tested with version 1.2-SNAPSHOT, BUILD_DATE: 2017-12-07T13:33:10Z</p>

</li>
<li><p><a href="https://graphdb.ontotext.com/documentation/standard/loading-data-using-ontorefine.html">OntoRefine</a>, which is an adaptation of OpenRefine for working with RDF data. It exposes a table as a virtual SPARQL endpoint (special service), where each column <b>col</b> of each row is exposed as a variable binding <b>?c_col</b>.</p>

</li>
</ul>

<p>We&#39;ve used TARQL to convert large files (over 10M rows, 145 columns) using complex TARQL queries (480 lines: 110 prefixes, 33 nodes, 250 triples, 110 binds).</p>

<p>We&#39;ve used OntoRefine for large and complex CSV files, e.g. Crunchbase consisting of 18 tables, total 10.5M rows, 318 columns; for both initial loading and data updates. See <a href="https://gist.github.com/VladimirAlexiev/d5d67feb002dbcfa6b3d4c3dd59b52da">CrunchBase Challenge</a> for details. (Please note that we use a customized script that works with named graph per <b>table row</b>, not per <b>table</b>.)</p>

<h2 id="Options">Options</h2>

<p>The default is to generate a SPARQL UPDATE query for OntoRefine. It encloses OntoRefine variables in a <b>service</b> clause that accesses the OntoRefine virtual SPARQL endpoint (see later about the handling of <b>PROJECT_ID</b>):</p>

<pre><code>  service &lt;rdf-mapper:ontorefine:PROJECT_ID&gt; {
    ...
  }</code></pre>

<p>This has several benefits:</p>

<ul>

<li><p>It ingests directly to GraphDB (without producing an intermediate RDF file), which is faster.</p>

</li>
<li><p>It overwrites a named graph, so it can be used for ingest or update. The first model line must look like this where <b>graph</b> is the graph to overwrite (in angle brackets).</p>

<pre><code>  ## GRAPH &lt;graph&gt;</code></pre>

</li>
<li><p>You can match real triples in GraphDB, which can be used to resolve entities (&quot;strings&quot; to &quot;things&quot;). A macro name that ends in &quot;URL&quot; (case-insensitively), e.g. <b>CB_AGENT_URL(permalink)</b>, causes the respective patterns to be interpreted outside of the OntoRefine virtual service.</p>

</li>
<li><p>You can split several multi-valued columns (using the <b>SPLIT</b> macro) to produce multiple bindings, without fear of Cartesian Product (i.e. their values will not be combined with each other).</p>

</li>
</ul>

<p>Option <b>-construct</b> generates a SPARQL CONSTRUCT query. You can still match GraphDB triples and use multiple multi-valued columns. Any <b>GRAPH</b> comment is ignored, because CONSTRUCT does not support graphs (see <a href="https://github.com/w3c/sparql-12/issues/31">SPARQL 1.2 issue 31</a>). The query produces intermediate RDF data that must be saved before loading to GraphDB, then you can use the <a href="https://www.w3.org/TR/sparql11-http-rdf-update/">SPARQL Graph Store Protocol</a> to overwrite the respective graph.</p>

<p>Option <b>--tarql</b> generates a TARQL CONSTRUCT query. You should put each multivalued column (together with the primary key column) in a distinct model to avoid Cartesian Product. You cannot match RDF data in a repository (see <a href="https://github.com/tarql/tarql/issues/25">TARQL issue 25</a>), use UPDATE (see <a href="https://github.com/tarql/tarql/issues/67">TARQL issue 67</a>), nor use graphs (see <a href="https://github.com/tarql/tarql/issues/98">TARQL issue 98</a>).</p>

<p>You can abbreviate options. All these are equivalent:</p>

<pre><code>  --c --co --construct
  --t --ta --tarql</code></pre>

<h2 id="Prerequisites">Prerequisites</h2>

<ul>

<li><p>OntoRefine or TARQL as described above</p>

</li>
<li><p>Perl. Tested with 5.32.1 (Straberry Perl on Cygwin)</p>

</li>
<li><p>Working CPP preprocessor. Tested with 8.3.0 (x86_64-posix-seh, Built by strawberryperl.com project)</p>

</li>
<li><p>A file (eg <b>prefixes.rq</b>) that defines all common prefixes and is prepended to the generated query</p>

</li>
<li><p>A file (eg <b>common.h</b>) that defines CPP preprocessor macros</p>

</li>
</ul>

<h2 id="Process">Process</h2>

<ul>

<li><p>Make a <b>rdfpuml</b> semantic model for a single table, using field names as parenthesized embeds. See below for several examples.</p>

</li>
<li><p>Run the script followed by the CPP proprocessor as shown above and save the SPARQL script</p>

</li>
</ul>

<p>To process CSV/TSV with the generated SPARQL scripts, use the following steps.</p>

<p>Process with <b>model.tarql</b> (variants for CSV or TSV):</p>

<pre><code>  tarql    model.tarql data.csv &gt; data.ttl
  tarql -t model.tarql data.tsv &gt; data.ttl</code></pre>

<p>Process <b>model-ontorefine.ru</b> with OntoRefine:</p>

<ul>

<li><p>Create a project, load tabular data</p>

</li>
<li><p>Optionally, perform data cleaning</p>

</li>
<li><p>Make sure you have a working GraphDB repository to receive the data</p>

</li>
<li><p>Paste the generated SPARQL into GraphDB workbench and adjust <b>PROJECT_ID</b> to the actual Refine virtual endpoint and project ID</p>

</li>
<li><p>Run the query to update the data in GraphDB</p>

</li>
</ul>

<p>If you save the OntoRefine cleaning script (operations JSON), you can automate the OntoRefine process by using the <a href="https://github.com/Ontotext-AD/ontorefine-client">ontorefine-client</a> CLI (it will become part of the OntoRefine distribution). We have scripts to automate the following steps:</p>

<ul>

<li><p>Create an OntoRefine project and capture its project ID</p>

</li>
<li><p>Load tabular data into the OntoRefine project</p>

</li>
<li><p>Optionally, apply an OpenRefine data cleaning script</p>

</li>
<li><p>Replace the placeholder <b>PROJECT_ID</b> in the generated query with the actual ID</p>

</li>
<li><p>Run the query against a GraphDB repository: it will replace the defined named graph</p>

</li>
<li><p>Delete the OntoRefine project</p>

</li>
</ul>

<h2 id="RDF-Model-Examples">RDF Model Examples</h2>

<p><b>rdfpuml</b> models are RDF Turtle examples that use parenthesized column names in URLs (&quot;templated URLs&quot;) and in attribute values (which can be datatyped).</p>

<p>They are valid Turtle, with the exception that RDF tools issue warnings about templated literals such as <b>&quot;(some_date)&quot;^^xsd:date</b> or <b>&quot;(amount)&quot;^^xsd:decimal</b>.</p>

<p>You can also use &quot;functions&quot; that you need to implement as CPP macros. <b>rdf2sparql</b> takes care to unroll the functions into BINDs, adding suffixes to variable names.</p>

<p>See also <b>test/customer</b> for a separate example (includes a Makefile).</p>

<h3 id="RDF-Model:-CrunchBase-Organizations">RDF Model: CrunchBase Organizations</h3>

<p>The first example is a simple semantic representation of Crunchbase&#39;s <b>organizations.csv</b> table:</p>

<pre><code>  ## GRAPH &lt;cb/graph/organizations&gt;
  
  &lt;cb/agent/(uuid)&gt; a cb:Organization;
    cb:uuid &#39;(uuid)&#39;;
    cb:name &#39;(name)&#39;;
    cb:permalink &#39;(permalink)&#39;;
    cb:url &#39;(cb_url)&#39;^^xsd:anyURI;
    cb:rank &#39;(rank)&#39;^^xsd:integer;
    cb:createdAt &#39;FIXDATE(created_at)&#39;^^xsd:dateTime;
    cb:updatedAt &#39;FIXDATE(updated_at)&#39;^^xsd:dateTime;
    cb:legalName &#39;(legal_name)&#39;;
    cb:organizationRole &lt;cb/organizationRole/URLIFY(SPLIT_COMMA(roles))&gt;;
    cb:domain &#39;(domain)&#39;;
    cb:homepageUrl &#39;(homepage_url)&#39;^^xsd:anyURI;
    cb:countryCode &#39;(country_code)&#39;;
    cb:stateCode &#39;(state_code)&#39;;
    cb:region &#39;(region)&#39;;
    cb:city &#39;(city)&#39;;
    cb:address &#39;(address)&#39;;
    cb:postalCode &#39;(postal_code)&#39;;
    cb:status &lt;cb/organizationStatus/URLIFY(status)&gt;;
    cb:shortDescription &#39;(short_description)&#39;;
    cb:industry &lt;cb/industry/URLIFY(SPLIT_COMMA(category_list))&gt;;
    cb:numFundingRounds &#39;(num_funding_rounds)&#39;^^xsd:integer;
    cb:totalFundingUsd &#39;(total_funding_usd)&#39;^^xsd:decimal;
    cb:totalFunding &#39;(total_funding)&#39;^^xsd:decimal;
    cb:totalFundingCurrencyCode &#39;(total_funding_currency_code)&#39;;
    cb:foundedOn &#39;FIXDATE(founded_on)&#39;^^xsd:dateTime;
    cb:lastFundingOn &#39;FIXDATE(last_funding_on)&#39;^^xsd:dateTime;
    cb:closedOn &#39;FIXDATE(closed_on)&#39;^^xsd:dateTime;
    cb:employeeCount &lt;cb/employeeCount/URLIFY(IFNOTNULL(employee_count))&gt;;
    cb:email &#39;(email)&#39;;
    cb:phone &#39;(phone)&#39;;
    cb:facebookUrl &#39;(facebook_url)&#39;^^xsd:anyURI;
    cb:linkedinUrl &#39;(linkedin_url)&#39;^^xsd:anyURI;
    cb:twitterUrl &#39;(twitter_url)&#39;^^xsd:anyURI;
    cb:logoUrl &#39;(logo_url)&#39;^^xsd:anyURI;
    cb:alias &#39;(alias1)&#39;;
    cb:alias &#39;(alias2)&#39;;
    cb:alias &#39;(alias3)&#39;;
    cb:primaryRole &lt;cb/organizationRole/URLIFY(primary_role)&gt;;
    cb:numExits &#39;(num_exits)&#39;^^xsd:integer.</code></pre>

<p>It puts all fields in one table and uses macros like URLIFY to make a phrase usable in URL, IFNOTNULL to discard parasitic phrases, SPLIT to split a multi-valued field into multiple bindings, etc. It uses a GRAPH comment to specify which named graph should be overwritten.</p>

<h3 id="RDF-Model:-Customers">RDF Model: Customers</h3>

<p>Next is an example about persons (customers).</p>

<pre><code>    &lt;person/(customer_id)&gt; a :NaturalPerson;
      :id &quot;(customer_id)&quot;;
      :firstName &quot;(first_name)&quot;;
      :lastName &quot;(last_name)&quot;;
      :gender &quot;(gender)&quot;;
      :religion &quot;(religion)&quot;;
      :hasAddress &lt;person/(customer_id)/address&gt;;
      :hasEvent  &lt;person/(customer_id)/birth&gt;;
      :hasEvent  &lt;person/(customer_id)/education&gt;.

    &lt;person/(customer_id)/address&gt; a :Address;
      :houseNumber &quot;(house_number)&quot;;
      :street &quot;(street)&quot;;
      :postalCode &quot;(postal_code)&quot;;
      :city &lt;country/(country)/city/URLIFY(city)&gt;;
      :country &lt;country/(country)&gt;.

    &lt;country/(country)/city/URLIFY(city)&gt; a :City; :country &lt;country/(country)&gt;; :name &quot;(city)&quot;.

    &lt;country/(country)&gt; a :Country; :code &quot;(country)&quot;.

    &lt;person/(customer_id)/birth&gt; a :BirthEvent; :hasDate &quot;(date_of_birth)&quot;^^xsd:date.

    &lt;person/(customer_id)/education&gt; a :EducationEvent;
      :hasDate &quot;(enrollment_date)&quot;^^xsd:date;
      :university &lt;university/URLIFY(university)&gt;;
      :degree &lt;degree/URLIFY(education_degree)&gt;.</code></pre>

<p>It dispatches fields to several nodes and uses only one macro (<b>URLIFY</b>).</p>

<h3 id="RDF-Model:-Annual-Revenue-by-Permalink">RDF Model: Annual Revenue by Permalink</h3>

<p>Next is a very simple model that adds &quot;revenue&quot; into to CrunchBase organizations.</p>

<pre><code>  ## GRAPH &lt;extra/revenue&gt;
  &lt;CB_AGENT_URL(permalink)&gt; ex:annualRevenueUsd &quot;(revenue)&quot;^^xsd:decimal.</code></pre>

<p>The revenue is keyed by &quot;permalink&quot; so we use the <b>CB_AGENT_URL()</b> macro to lookup by permalink.</p>

<h3 id="RDF-Model:-Grant-Spending-Categories">RDF Model: Grant Spending Categories</h3>

<p>This model of NIH grants assumes that an application (with primary key <b>APPLICATION_ID</b>) can have multiple spending categories (field <b>NIH_SPENDING_CATS</b>) separated by semi-colon. To avoid Cartesian Product with TARQL, we put this one field in a separate model file:</p>

<pre><code>  &lt;grant/(APPLICATION_ID)&gt; gr:spendingCategory &lt;spendingCategory/URLIFY(SPLIT_SEMI(NIH_SPENDING_CATS))&gt;.

  &lt;spendingCategory/URLIFY(SPLIT_SEMI(NIH_SPENDING_CATS))&gt;
    a skos:Concept ;
    skos:inScheme  &lt;spendingCategory&gt; ;
    skos:prefLabel &quot;SPLIT_SEMI(NIH_SPENDING_CATS)&quot;.

  &lt;spendingCategory&gt;
    a skos:ConceptScheme ;
    skos:prefLabel  &quot;NIH spending category&quot;.</code></pre>

<p>Note that in addition to making the <b>gr:spendingCategory</b> relation, this model also emits extra nodes. This will lead to redundant triples: each individual <b>skos:Concept</b> is duplicated as many times as it&#39;s used in grants, and <b>skos:ConceptScheme</b> is duplicated as the total number of grants.</p>

<p>This does not lead to conflicts since the same triple cannot be recorded multiple times in an RDF repository. However, if this data redundancy is bothersome, you can normalize the Concept data to a separate file of unique concepts; and move the ConceptScheme into a separate &quot;constant&quot; RDF file that doesn&#39;t need to be processed with <b>rdf2sparql</b>.</p>

<h3 id="RDF-Model-Concatenation">RDF Model Concatenation</h3>

<p><b>rdf2sparql</b> works on a single CSV table at a time (<b>rdf2rml</b> does not have this limitation). Furthermore, as seen above, you may need to split a model into &quot;component&quot; sub-models to handle multi-valued columns. Making diagrams from such tiny models is not very useful.</p>

<p>Luckily, concatenating several Turtle files is also a valid Turtle. So you can make an overall model by concatenating the component models.</p>

<p>Here is a Makefile from a recent project. It specifies how to make the overall <b>nih-model.ttl</b>, and then the diagram <b>nih-model.png</b> from it.</p>

<pre><code>  all: nih-model.ttl nih-model.png prefixes.rq

  nih-model.ttl: prefixes.ttl nih-activityType.ttl nih-applicationType.ttl nih-department.ttl \
    nih-funder.ttl nih-funding.ttl nih-fundingMechanism.ttl nih-grant.ttl nih-linkClinicalStudy.ttl \
    nih-linkPatent.ttl nih-linkPublication.ttl nih-principalInvestigator.ttl nih-researcher.ttl \
    nih-spendingCategory.ttl nih-studySection.ttl puml.ttl
          cat $^ | perl nih-model-rename.pl &gt; $@

  %.png: %.ttl
          rdfpuml.bat $*.ttl
          puml.bat $*.puml
          rm $*.puml

  prefixes.rq: prefixes.ttl
          perl -pe &#39;m{###} and last; s{^@}{}; s{ *\.$$}{}&#39; $^ &gt; $@</code></pre>

<p>It uses a shared <b>prefixes.ttl</b> and its SPARQL variant <b>prefixes.rq</b> that is prepended to any generated query. To ensure connectivity of the overall model, a script like <b>nih-model-rename.pl</b> renames URLs in object position (&quot;foreign keys&quot;) to respective URLs in subject position (&quot;primary keys&quot;), e.g.:</p>

<pre><code>  #!perl -p

  s{\Q/FIND_CONTACT(PI_IDS)}{/(PI_ID)};
  s{\Q/OMIT_CONTACT(PI_IDS)}{/(PI_ID)};
  s{\Q/FUNDER(FUNDING_ICs)}{/(FUNDING_IC)};</code></pre>

<h2 id="Preprocessor-Macros">Preprocessor Macros</h2>

<p>In addition to plain CSV field names you can also use macros (&quot;function calls&quot;) that are unrolled by the script into a series of binds using suffixed variable names. Below are some examples we&#39;ve used in various projects. These are implemented as CPP preprocessor macro definitions (e.g. in file <b>common.h</b>):</p>

<ul>

<li><p>make a name usable in URL. Replace punctuations with one underscore; remove leading/trailing punctuation. Support all Unicode alphanumeric chars. Convert alphabetical to lowercase.</p>

<pre><code>  #define URLIFY1(x)      lcase(replace(replace(replace(x, &quot;[^\\p{L}0-9]&quot;, &quot;_&quot;), &quot;_+&quot;, &quot;_&quot;), &quot;^_|_$&quot;, &quot;&quot;))</code></pre>

</li>
<li><p>same but also generates a bind to x_URLIFY</p>

<pre><code>  #define URLIFY(x)       bind(URLIFY1(x) as x##_URLIFY)</code></pre>

</li>
<li><p>replace space with &quot;T&quot; in a timestamp to conform to xsd:dateTime format</p>

<pre><code>  #define FIXDATETIME(x)  bind(replace(x,&#39; &#39;,&#39;T&#39;) as x##_FIXDATETIME)</code></pre>

</li>
<li><p>convert dates from mm/dd/yyyy to yyyy-mm-dd to conform to xsd:date forma</p>

<pre><code>  #define FIXDATE(x)      bind(replace(x,&quot;(..)/(..)/(....)&quot;,&quot;$3-$1-$2&quot;) as x##_FIXDATE)</code></pre>

</li>
<li><p>lookup a CrunchBase permalink to find the respective agent (organization or person) URL</p>

<pre><code>  #define CB_AGENT_URL(x) filter(bound(x)) x##_CB_AGENT_URL a x##_TYPE; k2:permalink x filter(x##_TYPE in (cb:Person,cb:Organization))</code></pre>

</li>
<li><p>filter out parasitic values (&quot;other&quot;,&quot;not provided&quot;,&quot;unknown&quot;)</p>

<pre><code>  #define IFNOTNULL(x)    bind(if(x in (&quot;other&quot;,&quot;not provided&quot;,&quot;unknown&quot;),?UNDEF,x) as x##_IFNOTNULL)</code></pre>

</li>
<li><p>filter out x values that are equal to ?y. Used to strip self-referential parent: CB category mentioning itself as category_group</p>

<pre><code>  #define IFNOTSAME(x,y)  bind(if(x=y,?UNDEF,x) as x##_IFNOTSAME)</code></pre>

</li>
<li><p>assign the first bound variable amongst the <b>...</b> arguments to variable <b>x##_COALESCE</b></p>

<pre><code>  #define COALESCE(x,...) bind(coalesce(__VA_ARGS__) as x##_COALESCE)</code></pre>

</li>
<li><p>map &quot;Yes&quot;,&quot;No&quot; to &quot;true&quot;,&quot;false&quot; respectively</p>

<pre><code>  #define YESNO(x)        bind(if(x=&quot;Yes&quot;,true,false) as x##_YESNO)</code></pre>

</li>
<li><p>split <b>x</b> on a given delimiter <b>y</b> and produce multiple bindings in variable <b>z</b></p>

<pre><code>  #define SPLIT(x,y,z)    z apf:strSplit (x y).</code></pre>

</li>
<li><p>split on semicolon (optionally followed by space) and produce multiple bindings.</p>

<pre><code>  #define SPLIT_SEMI(x)   SPLIT(x,&quot;; ?&quot;,x##_SPLIT_SEMI)</code></pre>

</li>
<li><p>split on comma (optionally followed by space) and produce multiple bindings.</p>

<pre><code>  #define SPLIT_COMMA(x)  SPLIT(x,&quot;, ?&quot;,x##_SPLIT_COMMA)</code></pre>

</li>
<li><p>find a numeric identifier element marked as &quot; (contact)&quot;</p>

<pre><code>  #define FIND_CONTACT(x) bind(replace(x, &quot;.*?([0-9]+) \\(contact\\).*&quot;, &quot;$1&quot;) as x##_FIND_CONTACT)</code></pre>

</li>
<li><p>split on semicolon and return all numeric identifiers except the one marked as &quot; (contact)&quot;</p>

<pre><code>  #define OMIT_CONTACT(x) SPLIT_SEMI(x)  bind(if(regex(x##_SPLIT_SEMI,&quot;^$| \\(contact\\)&quot;,?UNDEF,x##_SPLIT_SEMI) as x##_OMIT_CONTACT)</code></pre>

</li>
<li><p>split on backslash then return the first <b>:</b>-delimited part of each pair (funder code)</p>

<pre><code>  #define FUNDER(x)       SPLIT(x,&quot;\\\\&quot;,x##_SPLIT_BACKSL) bind(replace(x##_SPLIT_BACKSL,&quot;(.+):(.+)&quot;,&quot;$1&quot;) as x##_FUNDER)</code></pre>

</li>
<li><p>return the second <b>:</b>-delimited part of each pair (amount). Must be used together with <b>FUNDER(x)</b> because it uses <b>x##_SPLIT_BACKSL</b> without binding it</p>

<pre><code>  #define AMOUNT(x)                                        bind(replace(x##_SPLIT_BACKSL,&quot;(.+):(.+)&quot;,&quot;$2&quot;) as x##_AMOUNT)</code></pre>

</li>
</ul>

<p>Most of the macros implement binds (computations), but you can also use more specialized constructs. Notes about unusual constructs:</p>

<ul>

<li><p><b>URLIFY1(x)</b> uses the Unicode character class <b>\p{L}</b> for &quot;Letters&quot;</p>

</li>
<li><p><b>IFNOTNULL(x)</b> and <b>IFNOTSAME(x)</b> use a conditional and the variable <b>?UNDEF</b>, which by convention is never bound, so is undefined</p>

</li>
<li><p><b>##</b> concatenates two preprocessor tokens (a variable name and a constant string) to make a new variable name</p>

</li>
<li><p><b>CB_AGENT_URL(x)</b>: uses a real RDF lookup (outside of the OntoRefine virtual endpoint). Before that guards with <b>bound(x)</b> (otherwise an unbound variable will return all agents), then checks for respective <b>rdf:type</b></p>

</li>
<li><p><b>SPLIT(x)</b>: uses a &quot;magic predicate&quot; (<b>apf:strSplit</b> in TARQL or <b>spif:split</b> in OntoRefine) to split x and produce multiple bindings</p>

</li>
<li><p><b>COALESCE(x,...)</b> uses <b>__VA_ARGS__</b> to take any number of arguments (variadic arguments)</p>

</li>
<li><p><b>SPLIT(x,&quot;\\\\&quot;)</b> escapes backslash twice: once for a SPARQL string, and a second time for the regular expression taht it represents</p>

</li>
</ul>

<h3 id="Macro-Best-Practices">Macro Best Practices</h3>

<p>To save yourself some trouble, here are some hints for writing and using macros:</p>

<ul>

<li><p>Write builtin SPARQL functions in lowercase to avoid mistaking them for macro definitions</p>

</li>
<li><p>The script converts datatyped fields to UPPERCASE, so avoid source fields in all uppercase</p>

</li>
<li><p>To implement <b>SPLIT</b>, use <b>apf:strSplit</b> in TARQL and <b>spif:split</b> in OntoRefine. (In a future version, this tool may take care of that difference.)</p>

</li>
<li><p><b>SPLIT</b> delimiters often use URL-unfriendly chars. So don&#39;t use &quot;raw&quot; SPLIT with 2 arguments, but define &quot;business&quot; versions of SPLIT as above.</p>

</li>
<li><p>If you want to put comments in models, use double hash <b>##</b> since the single hash is interpreted as a preprocessor directive (even if there is a space after it)</p>

</li>
</ul>

<h2 id="Generated-SPARQL">Generated SPARQL</h2>

<p>The overall structure of the generated SPARQL query depends on the options you used.</p>

<p>For OntoRefine UPDATE:</p>

<pre><code>  delete where {graph $GRAPH {?s ?p ?o}};
  insert {graph $GRAPH {
    &lt;Insert Patterns&gt;
  }}
  where {
    service &lt;rdf-mapper:ontorefine:PROJECT_ID&gt; {
      &lt;Generated Binds&gt;
    }
    filter(bound(?permalink))
    ?permalink_CB_AGENT_URL a ?permalink_TYPE; cb:permalink ?permalink
    filter(?permalink_TYPE in (cb:Person,cb:Organization))
  };</code></pre>

<ul>

<li><p><b>$GRAPH</b> is the named graph mentioned in the first model line. This way the query can handle both initial data loading and updates. Please note that for Crunchbase it is unfeasible to regenerate all Organization data on every update. So we have a slightly more complex script (not published) that uses a named graph per table <b>row</b> (uuid) not per <b>table</b>, and selects only recently updated rows for processing.</p>

</li>
<li><p><b>PROJECT_ID</b> is a placeholder that must be replaced with the actual OntoRefine project ID before running the query.</p>

</li>
<li><p>The script has a special case for macro names matching <b>*_URL</b>, that&#39;s why the <b>CB_AGENT_URL</b> pattern is evaluated outside of the OntoRefine virtual endpoint.</p>

</li>
</ul>

<p>For OntoRefine CONSTRUCT:</p>

<pre><code>  construct {
    &lt;Insert Patterns&gt;
  }
  where {
    service &lt;rdf-mapper:ontorefine:PROJECT_ID&gt; {
      &lt;Generated Binds&gt;
    }
    filter(bound(?permalink))
    ?permalink_CB_AGENT_URL a ?permalink_TYPE; k2:permalink ?permalink
    filter(?permalink_TYPE in (cb:Person,cb:Organization))
  }</code></pre>

<p>CONSTRUCT doesn&#39;t work with named graphs, so any graph is ignored.</p>

<p>For TARQL CONSTRUCT:</p>

<pre><code>  construct {
    &lt;Insert Patterns&gt;
  }
  where {
    &lt;Generated Binds&gt;
  }</code></pre>

<p>TARQL cannot make a lookup in existing RDF data, so macro names matching <b>*_URL</b> are not allowed.</p>

<h3 id="Insert-Patterns:-Crunchbase-Organizations">Insert Patterns: Crunchbase Organizations</h3>

<p>The script unrolls macro (function) calls into binds, adding uppercase suffixes to the variable names. In addition, it knows how to process templatized URLs (see var names with a <b>_URL</b> suffix) and how to process datatype attachments (which uses variable names converted to uppercase). Compare the patterns below to the first model example:</p>

<pre><code>  ?cb_agent_uuid_URL a cb:Organization;
    cb:uuid ?uuid;
    cb:name ?name;
    cb:permalink ?permalink;
    cb:url ?CB_URL;
    cb:rank ?RANK;
    cb:createdAt ?CREATED_AT_FIXDATETIME;
    cb:updatedAt ?UPDATED_AT_FIXDATETIME;
    cb:legalName ?legal_name;
    cb:organizationRole ?cb_organizationRole_roles_SPLIT_URLIFY_URL;
    cb:domain ?domain;
    cb:homepageUrl ?HOMEPAGE_URL;
    cb:countryCode ?country_code;
    cb:stateCode ?state_code;
    cb:region ?region;
    cb:city ?city;
    cb:address ?address;
    cb:postalCode ?postal_code;
    cb:status ?cb_organizationStatus_status_URLIFY_URL;
    cb:shortDescription ?short_description;
    cb:industry ?cb_industry_category_list_SPLIT1_URLIFY_URL;
    cb:numFundingRounds ?NUM_FUNDING_ROUNDS;
    cb:totalFundingUsd ?TOTAL_FUNDING_USD;
    cb:totalFunding ?TOTAL_FUNDING;
    cb:totalFundingCurrencyCode ?total_funding_currency_code;
    cb:foundedOn ?FOUNDED_ON_FIXDATE;
    cb:lastFundingOn ?LAST_FUNDING_ON_FIXDATE;
    cb:closedOn ?CLOSED_ON_FIXDATE;
    cb:employeeCount ?cb_employeeCount_employee_count_IFNOTNULL_URLIFY_URL;
    cb:email ?email;
    cb:phone ?phone;
    cb:facebookUrl ?FACEBOOK_URL;
    cb:linkedinUrl ?LINKEDIN_URL;
    cb:twitterUrl ?TWITTER_URL;
    cb:logoUrl ?LOGO_URL;
    cb:alias ?alias1;
    cb:alias ?alias2;
    cb:alias ?alias3;
    cb:primaryRole ?cb_organizationRole_primary_role_URLIFY_URL;
    cb:numExits ?NUM_EXITS.</code></pre>

<h3 id="Generated-Pre-Binds">Generated Pre-Binds</h3>

<p>The script emits a bunch of bindings.</p>

<p>For OntoRefine, first come silly &quot;aliases&quot; for each variable used in the model because of some peculiarities of the OntoRefine virtual endpoint (issue <a href="https://ontotext.atlassian.net/browse/GDB-6600">GDB-6600</a>):</p>

<pre><code>    bind(?c_uuid as ?uuid)
    bind(?c_name as ?name)
    bind(?c_permalink as ?permalink)
    bind(?c_cb_url as ?cb_url)
    bind(?c_rank as ?rank)
    bind(?c_created_at as ?created_at)
    bind(?c_updated_at as ?updated_at)
    bind(?c_legal_name as ?legal_name)
    bind(?c_roles as ?roles)
    bind(?c_domain as ?domain)
    bind(?c_homepage_url as ?homepage_url)
    bind(?c_country_code as ?country_code)
    bind(?c_state_code as ?state_code)
    bind(?c_region as ?region)
    bind(?c_city as ?city)
    bind(?c_address as ?address)
    bind(?c_postal_code as ?postal_code)
    bind(?c_status as ?status)
    bind(?c_short_description as ?short_description)
    bind(?c_category_list as ?category_list)
    bind(?c_num_funding_rounds as ?num_funding_rounds)
    bind(?c_total_funding_usd as ?total_funding_usd)
    bind(?c_total_funding as ?total_funding)
    bind(?c_total_funding_currency_code as ?total_funding_currency_code)
    bind(?c_founded_on as ?founded_on)
    bind(?c_last_funding_on as ?last_funding_on)
    bind(?c_closed_on as ?closed_on)
    bind(?c_employee_count as ?employee_count)
    bind(?c_email as ?email)
    bind(?c_phone as ?phone)
    bind(?c_facebook_url as ?facebook_url)
    bind(?c_linkedin_url as ?linkedin_url)
    bind(?c_twitter_url as ?twitter_url)
    bind(?c_logo_url as ?logo_url)
    bind(?c_alias1 as ?alias1)
    bind(?c_alias2 as ?alias2)
    bind(?c_alias3 as ?alias3)
    bind(?c_primary_role as ?primary_role)
    bind(?c_num_exits as ?num_exits)</code></pre>

<h3 id="Generated-Binds:-CrunchBase-Organizations">Generated Binds: CrunchBase Organizations</h3>

<p>Then come a number of bindings generated by:</p>

<ul>

<li><p>Handling templated URLs (eg <b>?cb_agent_uuid_URL</b>),</p>

</li>
<li><p>Unrolling macro (function) calls into binds and suffixed variables (eg <b>?roles_SPLIT</b> and then <b>?roles_SPLIT_URLIFY</b>)</p>

</li>
<li><p>Implementing datatype casting using <b>strdt()</b> and binding to an uppercased variable name (eg <b>?CB_URL, ?RANK</b>)</p>

</li>
</ul>

<pre><code>  bind(iri(concat(&quot;cb/agent/&quot;,?uuid)) as ?cb_agent_uuid_URL)
  bind(strdt(?cb_url,xsd:anyURI) as ?CB_URL)
  bind(strdt(?rank,xsd:integer) as ?RANK)
  bind(replace(?created_at,&#39; &#39;,&#39;T&#39;) as ?created_at_FIXDATETIME)
  bind(strdt(?created_at_FIXDATETIME,xsd:dateTime) as ?CREATED_AT_FIXDATETIME)
  bind(replace(?updated_at,&#39; &#39;,&#39;T&#39;) as ?updated_at_FIXDATETIME)
  bind(strdt(?updated_at_FIXDATETIME,xsd:dateTime) as ?UPDATED_AT_FIXDATETIME)
  ?roles_SPLIT_COMMA spif:split (?roles &#39;,&#39;).
  bind(lcase(replace(replace(replace(?roles_SPLIT_COMMA, &quot;[^\\p{L}0-9]&quot;, &quot;_&quot;), &quot;_+&quot;, &quot;_&quot;), &quot;^_|_$&quot;, &quot;&quot;)) as ?roles_SPLIT_COMMA_URLIFY)
  bind(iri(concat(&quot;cb/organizationRole/&quot;,?roles_SPLIT_COMMA_URLIFY)) as ?cb_organizationRole_roles_SPLIT_COMMA_URLIFY_URL)
  bind(strdt(?homepage_url,xsd:anyURI) as ?HOMEPAGE_URL)
  bind(lcase(replace(replace(replace(?status, &quot;[^\\p{L}0-9]&quot;, &quot;_&quot;), &quot;_+&quot;, &quot;_&quot;), &quot;^_|_$&quot;, &quot;&quot;)) as ?status_URLIFY)
  bind(iri(concat(&quot;cb/organizationStatus/&quot;,?status_URLIFY)) as ?cb_organizationStatus_status_URLIFY_URL)
  ?category_list_SPLIT_COMMA spif:split (?category_list &#39;,&#39;).
  bind(lcase(replace(replace(replace(?category_list_SPLIT_COMMA, &quot;[^\\p{L}0-9]&quot;, &quot;_&quot;), &quot;_+&quot;, &quot;_&quot;), &quot;^_|_$&quot;, &quot;&quot;)) as ?category_list_SPLIT_COMMA_URLIFY)
  bind(iri(concat(&quot;cb/industry/&quot;,?category_list_SPLIT_COMMA_URLIFY)) as ?cb_industry_category_list_SPLIT_COMMA_URLIFY_URL)
  bind(strdt(?num_funding_rounds,xsd:integer) as ?NUM_FUNDING_ROUNDS)
  bind(strdt(?total_funding_usd,xsd:decimal) as ?TOTAL_FUNDING_USD)
  bind(strdt(?total_funding,xsd:decimal) as ?TOTAL_FUNDING)
  bind(replace(?founded_on,&#39; &#39;,&#39;T&#39;) as ?founded_on_FIXDATETIME)
  bind(strdt(?founded_on_FIXDATETIME,xsd:dateTime) as ?FOUNDED_ON_FIXDATETIME)
  bind(replace(?last_funding_on,&#39; &#39;,&#39;T&#39;) as ?last_funding_on_FIXDATETIME)
  bind(strdt(?last_funding_on_FIXDATETIME,xsd:dateTime) as ?LAST_FUNDING_ON_FIXDATETIME)
  bind(replace(?closed_on,&#39; &#39;,&#39;T&#39;) as ?closed_on_FIXDATETIME)
  bind(strdt(?closed_on_FIXDATETIME,xsd:dateTime) as ?CLOSED_ON_FIXDATETIME)
  bind(if(?employee_count in (&quot;other&quot;,&quot;not provided&quot;,&quot;unknown&quot;),?UNDEF,?employee_count) as ?employee_count_IFNOTNULL)
  bind(lcase(replace(replace(replace(?employee_count_IFNOTNULL, &quot;[^\\p{L}0-9]&quot;, &quot;_&quot;), &quot;_+&quot;, &quot;_&quot;), &quot;^_|_$&quot;, &quot;&quot;)) as ?employee_count_IFNOTNULL_URLIFY)
  bind(iri(concat(&quot;cb/employeeCount/&quot;,?employee_count_IFNOTNULL_URLIFY)) as ?cb_employeeCount_employee_count_IFNOTNULL_URLIFY_URL)
  bind(strdt(?facebook_url,xsd:anyURI) as ?FACEBOOK_URL)
  bind(strdt(?linkedin_url,xsd:anyURI) as ?LINKEDIN_URL)
  bind(strdt(?twitter_url,xsd:anyURI) as ?TWITTER_URL)
  bind(strdt(?logo_url,xsd:anyURI) as ?LOGO_URL)
  bind(lcase(replace(replace(replace(?primary_role, &quot;[^\\p{L}0-9]&quot;, &quot;_&quot;), &quot;_+&quot;, &quot;_&quot;), &quot;^_|_$&quot;, &quot;&quot;)) as ?primary_role_URLIFY)
  bind(iri(concat(&quot;cb/organizationRole/&quot;,?primary_role_URLIFY)) as ?cb_organizationRole_primary_role_URLIFY_URL)
  bind(strdt(?num_exits,xsd:integer) as ?NUM_EXITS)</code></pre>

<h3 id="Generated-Binds:-Customers">Generated Binds: Customers</h3>

<p>For the Customers example, the binds are pretty similar, but we use a slightly different definition of <b>URLIFY</b> (uses teh Unicode Numeric character class <b>\p{N}</b> instead of <b>0-9</b>).</p>

<pre><code>  bind(iri(concat(&quot;person/&quot;,?customer_id)) as ?person_URL)
  bind(iri(concat(&quot;person/&quot;,?customer_id,&quot;/address&quot;)) as ?person_address_URL)
  bind(iri(concat(&quot;person/&quot;,?customer_id,&quot;/birth&quot;)) as ?person_birth_URL)
  bind(iri(concat(&quot;person/&quot;,?customer_id,&quot;/education&quot;)) as ?person_education_URL)
  bind(replace(replace(replace(?city,&#39;[^\\p{L}\\p{N}]+&#39;,&#39;_&#39;),&#39;^_&#39;,&#39;&#39;),&#39;_$&#39;,&#39;&#39;) as ?city_URLIFY)
  bind(iri(concat(&quot;country/&quot;,?country,&quot;/city/&quot;,?city_URLIFY)) as ?country_city_URLIFY_URL)
  bind(iri(concat(&quot;country/&quot;,?country)) as ?country_URL)
  bind(strdt(?date_of_birth,xsd:date) as ?DATE_OF_BIRTH)
  bind(strdt(?enrollment_date,xsd:date) as ?ENROLLMENT_DATE)
  bind(replace(replace(replace(?university,&#39;[^\\p{L}\\p{N}]+&#39;,&#39;_&#39;),&#39;^_&#39;,&#39;&#39;),&#39;_$&#39;,&#39;&#39;) as ?university_URLIFY)
  bind(iri(concat(&quot;university/&quot;,university_URLIFY)) as ?university_URLIFY_URL)
  bind(replace(replace(replace(?education_degree,&#39;[^\\p{L}\\p{N}]+&#39;,&#39;_&#39;),&#39;^_&#39;,&#39;&#39;),&#39;_$&#39;,&#39;&#39;) as ?education_degree_URLIFY)
  bind(iri(concat(&quot;degree/&quot;,?education_degree_URLIFY)) as ?education_degree_URLIFY</code></pre>

<h3 id="Generated-Update:-Annual-Revenue-by-Permalink">Generated Update: Annual Revenue by Permalink</h3>

<p>This model adds some extra Revenue triples into a specified named graph. The overall OntoRefine UPDATE looks like this:</p>

<pre><code>  delete where {graph &lt;extra/revenue&gt; {?x ?p ?o}};
  insert {graph  &lt;extra/revenue&gt; {
    ?permalink_CB_AGENT_URL ex:annualRevenueUsd ?REVENUE
  }}
  where {
    service &lt;rdf-mapper:ontorefine:PROJECT_ID&gt; {
      bind(?c_revenue as ?revenue)
      bind(strdt(?revenue,xsd:decimal) as ?REVENUE)
    }
    filter(bound(?permalink))
    ?permalink_CB_AGENT_URL a ?permalink_TYPE; k2:permalink ?permalink
    filter(?permalink_TYPE in (cb:Person,cb:Organization))
  };</code></pre>

<p>As you can see, the <b>CB_AGENT_URL</b> macro is evaluated outside of the OntoRefine virtual endpoint.</p>

<h3 id="Generated-Binds:-Spending-Categories">Generated Binds: Spending Categories</h3>

<pre><code>  bind(iri(concat(&quot;grant/&quot;,?APPLICATION_ID)) as ?grant_APPLICATION_ID_URL)
  ?NIH_SPENDING_CATS_SPLIT apf:strSplit (?NIH_SPENDING_CATS &quot;; ?&quot;).
  bind(replace(replace(replace(?NIH_SPENDING_CATS_SPLIT_SEMI, &quot;[^\\p{L}0-9]&quot;, &quot;_&quot;), &quot;_+&quot;, &quot;_&quot;), &quot;^_|_$&quot;, &quot;&quot;) as ?NIH_SPENDING_CATS_SPLIT_SEMI_URLIFY)
  bind(iri(concat(&quot;spendingCategory/&quot;,?NIH_SPENDING_CATS_SPLIT_SEMI_URLIFY)) as ?spendingCategory_NIH_SPENDING_CATS_SPLIT_SEMI_URLIFY_URL)</code></pre>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p>The gist <a href="https://gist.github.com/VladimirAlexiev/d5d67feb002dbcfa6b3d4c3dd59b52da">Crunchbase Semantic Model and Challenge</a> that publishes all our Crunchbase models. It also shows an overall model diagram made by <b>rdfpuml</b>.</p>

<p>The issue <a href="https://github.com/kg-construct/best-practices/issues/7">Generate Transforms and Shapes from Models</a> in the Knowledge Graph Construct W3C community group &quot;Best Practices&quot; github project.</p>

<p><b>rdfpuml</b>: a tool that generates PlantUML diagrams from RDF examples.</p>

<p><b>rdf2rml</b>: a tool that generates R2RML transformations from RDF examples.</p>

<p><b>rdf2tarql</b>: a tool that generates TARQL queries from RDF examples.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Vladimir Alexiev, Ontotext Corp</p>

<p>Last update: 15-Aug-2022</p>


</body>

</html>


